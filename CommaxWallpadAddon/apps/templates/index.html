<!DOCTYPE html>
<html>
<head>
    <title>Commax Wallpad Controller</title>
    <meta charset="utf-8">
    <style>
        body { 
    font-family: Arial, sans-serif;
    margin: 20px;
    background-color: #aaaaaa;
}
.device-list {
    margin: 20px 0;
}
.device-card {
    border: 1px solid #ddd;
    padding: 15px;
    margin: 10px 0;
    border-radius: 5px;
}
button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}
button:hover {
    background-color: #45a049;
}
.packet-analyzer {
    margin: 20px 0;
    padding: 20px;
    background-color: #f5f5f5;
    border-radius: 5px;
}
.packet-result {
    margin-top: 15px;
    font-family: monospace;
}
input[type="text"] {
    width: 300px;
    padding: 8px;
    margin-right: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.error {
    color: #ff0000;
}
.packet-reference {
    margin-top: 20px;
    font-size: 0.9em;
}
.packet-reference table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
}
.packet-reference th, .packet-reference td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: left;
}
.packet-reference th {
    background-color: #f0f0f0;
}
.packet-reference code {
    background-color: #f8f8f8;
    padding: 2px 4px;
    border-radius: 3px;
    font-family: monospace;
}
.collapsible {
    background-color: #eee;
    color: #444;
    cursor: pointer;
    padding: 18px;
    width: 100%;
    border: none;
    text-align: left;
    outline: none;
    font-size: 15px;
}
.active, .collapsible:hover {
    background-color: #ccc;
}
.content {
    padding: 0 18px;
    display: none;
    overflow: hidden;
    background-color: #f1f1f1;
}
/* íƒ­ ìŠ¤íƒ€ì¼ */
.tab-container {
    margin-top: 20px;
}
.tab-buttons {
    overflow: hidden;
    border: 1px solid #ccc;
    background-color: #f1f1f1;
}
.tab-buttons button {
    background-color: inherit;
    float: left;
    border: none;
    outline: none;
    cursor: pointer;
    padding: 14px 16px;
    transition: 0.3s;
    color: black;
}
.tab-buttons button:hover {
    background-color: #ddd;
}
.tab-buttons button.active {
    background-color: #4CAF50;
    color: white;
}
.tab-content {
    display: none;
    padding: 6px 12px;
    border: 1px solid #ccc;
    border-top: none;
    animation: fadeEffect 1s;
}
/* íŒ¨í‚· ë¡œê·¸ ìŠ¤íƒ€ì¼ */
.packet-log {
    margin-top: 20px;
    padding: 20px;
    background-color: #f5f5f5;
    border-radius: 5px;
}
.packet-log-content {
    max-height: 300px;
    overflow-y: auto;
    font-family: monospace;
    background-color: #fff;
    padding: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.packet-log-entry {
    padding: 4px 0;
    border-bottom: 1px solid #eee;
    cursor: pointer;
}
.packet-log-entry:last-child {
    border-bottom: none;
}
.packet-log-entry:hover {
    background-color: #f0f0f0;
}
.packet-log-entry .timestamp {
    color: #666;
    font-size: 0.9em;
    margin-right: 10px;
}
.packet-log-entry.recv {
    color: #2196F3;
}
.packet-log-entry.send {
    color: #4CAF50;
}
.packet-type-label {
    display: inline-block;
    min-width: 50px;
    margin-right: 10px;
    font-size: 0.9em;
}
.device-label {
    display: inline-block;
    min-width: 120px;
    margin-right: 10px;
    font-size: 0.9em;
    color: #666;
}
.packet-log-entry.unknown-packet {
    opacity: 0.7;
}
@keyframes fadeEffect {
    from {opacity: 0;}
    to {opacity: 1;}
}
.device-section {
    margin: 20px 0 30px 0;
    padding: 20px;
    background-color: #f5f5f5;
    border-radius: 5px;
}
.device-section button {
    margin-bottom: 20px;
}
.packet-analyzer-section {
    margin-top: 30px;
}
.packet-analyzer {
    margin: 20px 0;
    padding: 20px;
    background-color: #f5f5f5;
    border-radius: 5px;
}
.packet-reference {
    margin: 30px 0;
}
.packet-log {
    margin: 30px 0;
    padding: 20px;
    background-color: #f5f5f5;
    border-radius: 5px;
}
.packet-builder {
    margin-bottom: 15px;
    padding: 10px;
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.packet-builder select {
    padding: 8px;
    margin-right: 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    min-width: 150px;
}
.byte-input {
    display: inline-block;
    margin-right: 10px;
    margin-bottom: 10px;
}
.byte-input input {
    width: 40px;
    text-align: center;
}
.byte-input select {
    min-width: 100px;
}
.byte-label {
    display: block;
    font-size: 0.8em;
    color: #666;
    margin-bottom: 3px;
}
.packet {
    font-family: monospace;
    word-spacing: 1em;  /* ë°”ì´íŠ¸ ê°„ê²© */
}
.packet::before {
    content: attr(data-packet);
    letter-spacing: 0;  /* ê° ë°”ì´íŠ¸ ë‚´ ì ê°„ê²© ì œê±° */
}
.byte-spaced {
    font-family: monospace;
    word-spacing: 1em;
}
.byte-spaced::before {
    content: attr(data-packet);
    letter-spacing: 0;
}
.packet-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
}
.packet-table th, .packet-table td {
    border: 1px solid #ddd;
    padding: 8px;
    text-align: center;
}
.packet-table th {
    background-color: #f5f5f5;
    font-weight: bold;
}
.packet-table tr:nth-child(even) {
    background-color: #f9f9f9;
}
.packet-table .byte-header {
    background-color: #eef;
    font-weight: bold;
}
.packet-table .command-cell {
    font-family: monospace;
}
.packet-examples {
    margin: 20px 0;
    padding: 10px;
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 4px;
}
.packet-example {
    margin: 10px 0;
    padding: 5px 0;
    border-bottom: 1px solid #eee;
}
.packet-example:last-child {
    border-bottom: none;
}
.packet-example small {
    display: block;
    color: #666;
    margin-top: 5px;
}
.device-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
    background-color: #fff;
    border-radius: 4px;
    overflow: hidden;
}
.device-table th, .device-table td {
    padding: 8px 12px;
    text-align: left;
    border-bottom: 1px solid #eee;
}
.device-table th {
    background-color: #f8f9fa;
    font-weight: bold;
    color: #495057;
}
.device-table tr:last-child td {
    border-bottom: none;
}
.device-table tr:hover td {
    background-color: #f8f9fa;
} 
    </style>
</head>
<body>
    <h1>Commax Wallpad Controller</h1>
    
    <div class="device-section">
        <h2>ì—°ê²°ëœ ê¸°ê¸°</h2>
        <div class="device-list" id="deviceList">
            <!-- ê¸°ê¸° ëª©ë¡ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
        </div>
    </div>
    
    <div class="packet-log">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2>ê°ì§€ëœ íŒ¨í‚· ëª©ë¡</h2>
            <span style="color: #666; font-size: 0.9em;">
                ìµœê·¼ ìˆ˜ì‹ /ì†¡ì‹ ëœ íŒ¨í‚· ì¤‘ ì¤‘ë³µì„ ì œì™¸í•œ ëª©ë¡ì…ë‹ˆë‹¤. 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
            </span>
            <div>
                <label>
                    <input type="checkbox" id="hideUnknown" onchange="updatePacketLogDisplay()"> Unknown íŒ¨í‚· ìˆ¨ê¸°ê¸°
                </label>
                <button onclick="clearPacketLog()">ë¡œê·¸ ì§€ìš°ê¸°</button>
            </div>
        </div>
        <div class="packet-log-content" id="packetLog">
            <!-- íŒ¨í‚· ë¡œê·¸ê°€ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
        </div>
    </div>

    <div class="packet-reference">
        <button type="button" class="collapsible">ğŸ“š íŒ¨í‚· ì°¸ì¡° ìë£Œ</button>
        <div class="content">
            <div class="tab-container">
                <div class="tab-buttons" id="deviceTabs">
                    <!-- íƒ­ ë²„íŠ¼ì´ ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
                </div>
                <div id="tabContents">
                    <!-- ê° ë””ë°”ì´ìŠ¤ë³„ íŒ¨í‚· í…Œì´ë¸”ì´ ì—¬ê¸°ì— ì¶”ê°€ë©ë‹ˆë‹¤ -->
                </div>
            </div>
            <p><small>* ëª¨ë“  íŒ¨í‚·ì€ ì²´í¬ì„¬ì´ ìë™ìœ¼ë¡œ ê³„ì‚°ë˜ì–´ ì¶”ê°€ë©ë‹ˆë‹¤.</small></p>
        </div>
    </div>
    
    <div class="packet-analyzer-section">
        <div class="packet-analyzer">
            <h2>íŒ¨í‚· ë¶„ì„ê¸°</h2>
            <p><small>* íŒ¨í‚·ì€ 7ë°”ì´íŠ¸(14ìë¦¬)ë¡œ ì…ë ¥í•˜ì„¸ìš”. ì²´í¬ì„¬ì€ ìë™ìœ¼ë¡œ ê³„ì‚°ë©ë‹ˆë‹¤.</small></p>
            <div class="packet-builder">
                <div>
                    <select id="packetHeaderSelect" onchange="handleHeaderSelect()">
                        <option value="">í—¤ë” ì„ íƒ...</option>
                    </select>
                    <div id="packetByteInputs" style="display: inline-block;">
                        <!-- ë°”ì´íŠ¸ ì…ë ¥ í•„ë“œê°€ ë™ì ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤ -->
                    </div>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <div style="flex-grow: 1; display: flex; gap: 10px;">
                    <input type="text" id="packetInput" placeholder="íŒ¨í‚· ì…ë ¥ (ì˜ˆ: F7010104000000)">
                    <select id="packetHistory" style="min-width: 100px;" onchange="loadPacketFromHistory()">
                        <option value="">ìµœê·¼ ì…ë ¥...</option>
                    </select>
                </div>
                <button onclick="analyzePacket()">ë¶„ì„</button>
            </div>
            <div class="packet-result" id="packetResult">
                <!-- ë¶„ì„ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
            </div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜ ì„ ì–¸
let lastPackets = new Set();
let packetSuggestions = null;
const HISTORY_KEY = 'packet_analysis_history';
const MAX_HISTORY = 20;

// íŒ¨í‚· ë¶„ì„ í•¨ìˆ˜
function analyzePacket() {
    const packetInput = document.getElementById('packetInput');
    const resultDiv = document.getElementById('packetResult');
    // ì…ë ¥ê°’ì—ì„œ ê³µë°± ì œê±°
    const packet = packetInput.value.replace(/\s+/g, '').trim();
    
    if (!packet) {
        resultDiv.innerHTML = '<p class="error">íŒ¨í‚·ì„ ì…ë ¥í•˜ì„¸ìš”.</p>';
        return;
    }
    
    if (!/^[0-9A-Fa-f]{14}$/.test(packet) && !/^[0-9A-Fa-f]{16}$/.test(packet)) {
        resultDiv.innerHTML = '<p class="error">íŒ¨í‚·ì€ 7ë°”ì´íŠ¸(14ìë¦¬) ë˜ëŠ” 8ë°”ì´íŠ¸(16ìë¦¬)ì—¬ì•¼ í•©ë‹ˆë‹¤.</p>';
        return;
    }
    
    // íˆìŠ¤í† ë¦¬ì— ì €ì¥
    savePacketHistory(packet);
    
    // í—¤ë”ë¡œ íŒ¨í‚· íƒ€ì… ìë™ ê°ì§€
    const header = packet.substring(0, 2);
    let packetType = 'command';  // ê¸°ë³¸ê°’
    
    // packetSuggestionsì´ ì´ˆê¸°í™”ëœ ê²½ìš°ì—ë§Œ íŒ¨í‚· íƒ€ì… ê°ì§€ ì‹œë„
    if (packetSuggestions && packetSuggestions.headers) {
        const isState = packetSuggestions.headers.state.some(h => h.header === header);
        const isStateRequest = packetSuggestions.headers.state_request.some(h => h.header === header);
        const isAck = packetSuggestions.headers.ack.some(h => h.header === header);
        if (isState) {
            packetType = 'state';
        } else if (isStateRequest) {
            packetType = 'state_request';
        } else if (isAck) {
            packetType = 'ack';
        }
    }
    
    fetch('./api/analyze_packet', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
            command: packet,
            type: packetType
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            let html = '<h3>ë¶„ì„ ê²°ê³¼:</h3>';
            if (packetType === 'command') {
                html += `<p>íŒ¨í‚· íƒ€ì…: <strong>ëª…ë ¹</strong></p>`;
            } else if (packetType === 'state') {
                html += `<p>íŒ¨í‚· íƒ€ì…: <strong>ìƒíƒœ</strong></p>`;
            } else if (packetType === 'state_request') {
                html += `<p>íŒ¨í‚· íƒ€ì…: <strong>ìƒíƒœ ìš”ì²­</strong></p>`;
            } else if (packetType === 'ack') {
                html += `<p>íŒ¨í‚· íƒ€ì…: <strong>ì‘ë‹µ</strong></p>`;
            }
            html += `<p>ê¸°ê¸°: <strong>${data.device}</strong></p>`;
            
            if (data.checksum) {
                const formattedChecksum = data.checksum.match(/.{2}/g).join(' ');
                html += `<p>ì²´í¬ì„¬ì´ í¬í•¨ëœ íŒ¨í‚·: <strong class="byte-spaced" data-packet="${formattedChecksum}">&nbsp;</strong></p>`;
            } else {
                html += '<p class="error">ì²´í¬ì„¬ ê³„ì‚° ì‹¤íŒ¨</p>';
            }
            
            if (data.analysis && data.analysis.length > 0) {
                html += '<h4>ë°”ì´íŠ¸ë³„ ë¶„ì„:</h4>';
                html += '<div style="font-family: monospace;">';
                data.analysis.forEach(desc => {
                    html += `<div>${desc}</div>`;
                });
                html += '</div>';
            }
            
            if (packetType === 'command' && data.expected_state) {
                const formattedExpectedPacket = data.expected_state.expected_packet.match(/.{2}/g).join(' ');
                html += `<h4>ì˜ˆìƒë˜ëŠ” ìƒíƒœ íŒ¨í‚·:</h4>`;
                html += `<p><strong><a href="#" onclick="analyzeExpectedState('${data.expected_state.expected_packet}')" style="color: #2196F3; text-decoration: none;" class="byte-spaced" data-packet="${formattedExpectedPacket}">&nbsp;</a></strong></p>`;
                html += `<p>í•„ìˆ˜ ë°”ì´íŠ¸ ìœ„ì¹˜: ${data.expected_state.required_bytes.join(', ')}</p>`;
                
                if (data.expected_state.analysis && data.expected_state.analysis.length > 0) {
                    html += '<h4>ì˜ˆìƒ íŒ¨í‚· ë°”ì´íŠ¸ë³„ ë¶„ì„:</h4>';
                    html += '<div style="font-family: monospace;">';
                    data.expected_state.analysis.forEach(desc => {
                        html += `<div>${desc}</div>`;
                    });
                    html += '</div>';
                }
            }
            
            resultDiv.innerHTML = html;
        } else {
            resultDiv.innerHTML = `<p class="error">ì˜¤ë¥˜: ${data.error}</p>`;
        }
    })
    .catch(error => {
        resultDiv.innerHTML = `<p class="error">ìš”ì²­ ì‹¤íŒ¨: ${error}</p>`;
    });
}

// íŒ¨í‚· ë¡œê·¸ ì—…ë°ì´íŠ¸
function updatePacketLog() {
    fetch('./api/packet_logs')
        .then(response => response.json())
        .then(data => {
            const logDiv = document.getElementById('packetLog');
            let newContent = '';
            
            // ì†¡ì‹  íŒ¨í‚· ì²˜ë¦¬
            const newSendPackets = data.send.filter(packet => !lastPackets.has('send:' + packet.packet));
            newSendPackets.forEach(packet => {
                const timestamp = new Date().toLocaleTimeString();
                newContent += createPacketLogEntry(timestamp, packet, 'send');
                lastPackets.add('send:' + packet.packet);
            });
            
            // ìˆ˜ì‹  íŒ¨í‚· ì²˜ë¦¬
            const newRecvPackets = data.recv.filter(packet => !lastPackets.has('recv:' + packet.packet));
            newRecvPackets.forEach(packet => {
                const timestamp = new Date().toLocaleTimeString();
                newContent += createPacketLogEntry(timestamp, packet, 'recv');
                lastPackets.add('recv:' + packet.packet);
            });
            
            if (newContent) {
                logDiv.innerHTML = newContent + logDiv.innerHTML;
            }
        });
}

function createPacketLogEntry(timestamp, packet, type) {
    // íŒ¨í‚· ì •ë³´ì—ì„œ ì²« ë²ˆì§¸ ê²°ê³¼ ì‚¬ìš© (ì—†ëŠ” ê²½ìš° Unknownìœ¼ë¡œ ì²˜ë¦¬)
    const deviceInfo = packet.results.length > 0 ? packet.results[0] : { device: 'Unknown', packet_type: 'Unknown' };
    const deviceText = deviceInfo.device !== "Unknown" ? 
        `${deviceInfo.device} ${deviceInfo.packet_type}` : 
        "Unknown";
    
    // íŒ¨í‚·ì„ 2ìë¦¬ì”© ë¶„í• 
    const formattedPacket = packet.packet.match(/.{2}/g).join(' ');
    
    return `
        <div class="packet-log-entry ${type} ${deviceInfo.device === 'Unknown' ? 'unknown-packet' : ''}" onclick="handlePacketClick('${packet.packet}')">
            <span class="timestamp">${timestamp}</span>
            <span class="packet-type-label">[${type.toUpperCase()}]</span>
            <span class="packet" data-packet="${formattedPacket}">&nbsp;</span>
            <span class="device-label">[${deviceText}]</span>
        </div>`;
}

function handlePacketClick(packet, type) {
    document.getElementById('packetInput').value = packet;
    analyzePacket();
}

// íŒ¨í‚· êµ¬ì¡° ì •ë³´ ë¡œë“œ
function loadPacketStructures() {
    fetch('./api/packet_structures')
        .then(response => response.json())
        .then(structures => {
            const tabButtons = document.getElementById('deviceTabs');
            const tabContents = document.getElementById('tabContents');
            tabButtons.innerHTML = '';
            tabContents.innerHTML = '';
            
            let isFirst = true;
            
            for (const [deviceName, info] of Object.entries(structures)) {
                // íƒ­ ë²„íŠ¼ ì¶”ê°€
                const button = document.createElement('button');
                button.className = `tablinks ${isFirst ? 'active' : ''}`;
                button.onclick = function(evt) { openDeviceTab(evt, deviceName); };
                button.textContent = deviceName;
                tabButtons.appendChild(button);
                
                // íƒ­ ë‚´ìš© ìƒì„±
                const tabContent = document.createElement('div');
                tabContent.id = deviceName;
                tabContent.className = 'tab-content';
                tabContent.style.display = isFirst ? 'block' : 'none';
                
                // ë””ë°”ì´ìŠ¤ ì •ë³´ í—¤ë” ì¶”ê°€
                const deviceHeader = document.createElement('h3');
                deviceHeader.textContent = `${deviceName} (${info.type || 'ì•Œ ìˆ˜ ì—†ìŒ'})`;
                tabContent.appendChild(deviceHeader);
                
                // ìƒˆë¡œìš´ íŒ¨í‚· í…Œì´ë¸” ìƒì„±
                const table = createPacketTable(info);
                tabContent.appendChild(table);
                
                // ì˜ˆì‹œ íŒ¨í‚· ì„¹ì…˜ ì¶”ê°€
                if (info.command?.examples?.length > 0 || 
                    info.state?.examples?.length > 0 || 
                    info.state_request?.examples?.length > 0 || 
                    info.ack?.examples?.length > 0) {
                    
                    const examplesHeader = document.createElement('h4');
                    examplesHeader.textContent = 'ì˜ˆì‹œ íŒ¨í‚·';
                    tabContent.appendChild(examplesHeader);
                    
                    const examplesDiv = document.createElement('div');
                    examplesDiv.className = 'packet-examples';
                    
                    // ê° íƒ€ì…ë³„ ì˜ˆì‹œ ì¶”ê°€
                    ['command', 'state', 'state_request', 'ack'].forEach(type => {
                        if (info[type]?.examples?.length > 0) {
                            const typeHeader = document.createElement('h5');
                            typeHeader.textContent = {
                                'command': 'ëª…ë ¹ íŒ¨í‚·',
                                'state': 'ìƒíƒœ íŒ¨í‚·',
                                'state_request': 'ìƒíƒœ ìš”ì²­ íŒ¨í‚·',
                                'ack': 'ì‘ë‹µ íŒ¨í‚·'
                            }[type];
                            examplesDiv.appendChild(typeHeader);
                            
                            info[type].examples.forEach(example => {
                                const exampleDiv = document.createElement('div');
                                exampleDiv.className = 'packet-example';
                                const formattedPacket = example.packet.match(/.{2}/g).join(' ');
                                exampleDiv.innerHTML = `
                                    <code class="byte-spaced" data-packet="${formattedPacket}">&nbsp;</code>
                                    <small>${example.desc || ''}</small>
                                `;
                                examplesDiv.appendChild(exampleDiv);
                            });
                        }
                    });
                    
                    tabContent.appendChild(examplesDiv);
                }
                
                tabContents.appendChild(tabContent);
                isFirst = false;
            }
        })
        .catch(error => {
            console.error('íŒ¨í‚· êµ¬ì¡° ë¡œë“œ ì‹¤íŒ¨:', error);
        });
}
// íŒ¨í‚· íˆìŠ¤í† ë¦¬ ê´€ë ¨ í•¨ìˆ˜ë“¤
function loadPacketHistory() {
    try {
        return JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');
    } catch {
        return [];
    }
}

function savePacketHistory(packet) {
    if (!packet) return;
    
    let history = loadPacketHistory();
    
    // ì¤‘ë³µ ì œê±°
    history = history.filter(p => p !== packet);
    
    // ìƒˆ íŒ¨í‚·ì„ ì•ì— ì¶”ê°€
    history.unshift(packet);
    
    // ìµœëŒ€ ê°œìˆ˜ ìœ ì§€
    if (history.length > MAX_HISTORY) {
        history = history.slice(0, MAX_HISTORY);
    }
    
    localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    updateHistorySelect();
}

function updateHistorySelect() {
    const history = loadPacketHistory();
    const select = document.getElementById('packetHistory');
    
    // ì˜µì…˜ ì œê±° (ì²« ë²ˆì§¸ ì˜µì…˜ ì œì™¸)
    while (select.options.length > 1) {
        select.remove(1);
    }
    
    // íˆìŠ¤í† ë¦¬ ì˜µì…˜ ì¶”ê°€
    history.forEach(packet => {
        const formattedPacket = packet.match(/.{2}/g).join(' ');
        const option = document.createElement('option');
        option.value = packet;
        option.setAttribute('data-packet', formattedPacket);
        option.className = 'byte-spaced';
        option.innerHTML = '&nbsp;';
        select.appendChild(option);
    });
}

function loadPacketFromHistory() {
    const select = document.getElementById('packetHistory');
    const packet = select.value;
    if (packet) {
        document.getElementById('packetInput').value = packet;
        analyzePacket();
        select.selectedIndex = 0;  // ì„ íƒ ì´ˆê¸°í™”
    }
}

// Enter í‚¤ ì…ë ¥ ì²˜ë¦¬
document.getElementById('packetInput').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        analyzePacket();
    }
});

function updateDeviceList() {
    fetch('./api/devices')
        .then(response => response.json())
        .then(devices => {
            const deviceList = document.getElementById('deviceList');
            deviceList.innerHTML = '';
            
            const deviceTable = document.createElement('table');
            deviceTable.className = 'device-table';
            
            // í—¤ë” í–‰ ì¶”ê°€
            const headerRow = document.createElement('tr');
            ['ê¸°ê¸°', 'íƒ€ì…', 'ê°œìˆ˜'].forEach(header => {
                const th = document.createElement('th');
                th.textContent = header;
                headerRow.appendChild(th);
            });
            deviceTable.appendChild(headerRow);
            
            // ê¸°ê¸° ì •ë³´ í–‰ ì¶”ê°€
            for (const [deviceName, info] of Object.entries(devices)) {
                const row = document.createElement('tr');
                
                const nameCell = document.createElement('td');
                nameCell.textContent = deviceName;
                
                const typeCell = document.createElement('td');
                typeCell.textContent = info.type;
                
                const countCell = document.createElement('td');
                countCell.textContent = info.count;
                
                row.appendChild(nameCell);
                row.appendChild(typeCell);
                row.appendChild(countCell);
                deviceTable.appendChild(row);
            }
            
            deviceList.appendChild(deviceTable);
        });
}

// ì´ˆê¸°í™” í•¨ìˆ˜
function initialize() {
    initializePacketBuilder();  // íŒ¨í‚· ë¹Œë” ì´ˆê¸°í™” (packetSuggestions ì„¤ì •)
    updateHistorySelect();      // íˆìŠ¤í† ë¦¬ ë¡œë“œ
    updateDeviceList();         // ê¸°ê¸° ëª©ë¡ ë¡œë“œ
    updatePacketLog();          // íŒ¨í‚· ë¡œê·¸ ì´ˆê¸° ë¡œë“œ
    loadPacketStructures();     // íŒ¨í‚· êµ¬ì¡° ì •ë³´ ë¡œë“œ
}

// í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ í›„ ì´ˆê¸°í™” ì‹¤í–‰ ë° ì£¼ê¸°ì  ì—…ë°ì´íŠ¸ ì„¤ì •
document.addEventListener('DOMContentLoaded', function() {
    initialize(); // ì´ˆê¸°í™” í•¨ìˆ˜ í˜¸ì¶œ

    // ì£¼ê¸°ì  ì—…ë°ì´íŠ¸ ì„¤ì •
    setInterval(updateDeviceList, 30000);  // 30ì´ˆë§ˆë‹¤ ìƒíƒœ ì—…ë°ì´íŠ¸
    setInterval(updatePacketLog, 1000);    // 1ì´ˆë§ˆë‹¤ íŒ¨í‚· ë¡œê·¸ ì—…ë°ì´íŠ¸

    // íŒ¨í‚· ì…ë ¥ í•„ìš” ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
    const packetInput = document.getElementById('packetInput');
    if (packetInput) {
        packetInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                analyzePacket();
            }
        });
    }
});

// íŒ¨í‚· ë¡œê·¸ ì§€ìš°ê¸°
function clearPacketLog() {
    const logDiv = document.getElementById('packetLog');
    logDiv.innerHTML = '';
    lastPackets.clear();
}

// ì ‘ ìˆ˜ ìˆëŠ” ì°¸ì¡° ìë£Œ ì„¹ì…˜ ê¸°ëŠ¥
var coll = document.getElementsByClassName("collapsible");
for (var i = 0; i < coll.length; i++) {
    coll[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var content = this.nextElementSibling;
        if (content.style.display === "block") {
            content.style.display = "none";
        } else {
            content.style.display = "block";
        }
    });
}

function openDeviceTab(evt, deviceName) {
    var i, tabcontent, tablinks;
    
    // ëª¨ë“  íƒ­ ë‚´ìš© ìˆ¨ê¸°ê¸°
    tabcontent = document.getElementsByClassName("tab-content");
    for (i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
    }
    
    // ëª¨ë“  íƒ­ ë²„íŠ¼ ë¹„í™œì„±í™”
    tablinks = document.getElementsByClassName("tablinks");
    for (i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
    }
    
    // ì„ íƒëœ íƒ­ ë‚´ìš© í‘œì‹œ ë° ë²„íŠ¼ í™œì„±í™”
    document.getElementById(deviceName).style.display = "block";
    evt.currentTarget.className += " active";
}

function analyzeExpectedState(packet) {
    document.getElementById('packetInput').value = packet;
    analyzePacket();
}

// íŒ¨í‚· ë¡œê·¸ í‘œì‹œ ì—…ë°ì´íŠ¸
function updatePacketLogDisplay() {
    const hideUnknown = document.getElementById('hideUnknown').checked;
    const unknownPackets = document.querySelectorAll('.unknown-packet');
    
    unknownPackets.forEach(packet => {
        packet.style.display = hideUnknown ? 'none' : '';
    });
}

// íŒ¨í‚· ì…ë ¥ ë„ìš°ë¯¸ ì´ˆê¸°í™”
function initializePacketBuilder() {
    fetch('./api/packet_suggestions')
        .then(response => response.json())
        .then(data => {
            packetSuggestions = data;

            // ëª¨ë“  í—¤ë” ì˜µì…˜ ì¶”ê°€
            const headerSelect = document.getElementById('packetHeaderSelect');
            headerSelect.innerHTML = '<option value="">í—¤ë” ì„ íƒ...</option>'; // ê¸°ì¡´ ì˜µì…˜ ì œê±°

            // ëª…ë ¹ íŒ¨í‚· í—¤ë”
            const commandGroup = document.createElement('optgroup');
            commandGroup.label = 'ëª…ë ¹ íŒ¨í‚·';
            data.headers.command.forEach(header => {
                const option = document.createElement('option');
                option.value = `command:${header.header}`;
                option.textContent = `${header.device} (${header.header})`;
                commandGroup.appendChild(option);
            });

            // ìƒíƒœ íŒ¨í‚· í—¤ë”
            const stateGroup = document.createElement('optgroup');
            stateGroup.label = 'ìƒíƒœ íŒ¨í‚·';
            data.headers.state.forEach(header => {
                const option = document.createElement('option');
                option.value = `state:${header.header}`;
                option.textContent = `${header.device} (${header.header})`;
                stateGroup.appendChild(option);
            });
            
            // ìƒíƒœ ìš”ì²­ íŒ¨í‚· í—¤ë”
            const stateRequestGroup = document.createElement('optgroup');
            stateRequestGroup.label = 'ìƒíƒœ ìš”ì²­ íŒ¨í‚·';
            data.headers.state_request.forEach(header => {
                const option = document.createElement('option');
                option.value = `state_request:${header.header}`;
                option.textContent = `${header.device} (${header.header})`;
                stateRequestGroup.appendChild(option);
            });
            
            // ì‘ë‹µ íŒ¨í‚· í—¤ë”
            const ackGroup = document.createElement('optgroup');
            ackGroup.label = 'ì‘ë‹µ íŒ¨í‚·';
            data.headers.ack.forEach(header => {
                const option = document.createElement('option');
                option.value = `ack:${header.header}`;
                option.textContent = `${header.device} (${header.header})`;
                ackGroup.appendChild(option);
            });

            // í—¤ë” ì„ íƒ ì—˜ë¦¬ë¨¼íŠ¸ì— ê·¸ë£¹ ì¶”ê°€ (ï¿½ï¿½ ë²ˆë§Œ)
            headerSelect.appendChild(commandGroup);
            headerSelect.appendChild(stateGroup);
            headerSelect.appendChild(stateRequestGroup);
            headerSelect.appendChild(ackGroup);
        });
}

function handleHeaderSelect() {
    const headerSelect = document.getElementById('packetHeaderSelect');
    const byteInputsDiv = document.getElementById('packetByteInputs');
    const packetInput = document.getElementById('packetInput');
    
    const selectedValue = headerSelect.value;
    if (!selectedValue) {
        byteInputsDiv.innerHTML = '';
        return;
    }
    
    const [type, header] = selectedValue.split(':');
    
    // ì„ íƒëœ í—¤ë”ì— í•´ë‹¹í•˜ëŠ” ê¸°ê¸° ì°¾ê¸°
    const deviceInfo = packetSuggestions.headers[type].find(h => h.header === header);
    if (!deviceInfo) return;
    
    const deviceKey = `${deviceInfo.device}_${type}`;
    
    // ë°”ì´íŠ¸ ì…ë ¥ í•„ë“œ ìƒì„± (7ë°”ì´íŠ¸)
    let html = '';
    for (let i = 1; i < 7; i++) {
        const byteInfo = packetSuggestions.values[deviceKey]?.[i];
        if (byteInfo) {
            html += `
                <div class="byte-input">
                    <label class="byte-label">Byte ${i}: ${byteInfo.name}</label>
                    <select onchange="updatePacket()" data-byte="${i}">
                        <option value="">ì„ íƒ...</option>
                        ${Object.entries(byteInfo.values).map(([key, value]) => 
                            `<option value="${value}">${key} (${value})</option>`
                        ).join('')}
                    </select>
                </div>`;
        } else {
            html += `
                <div class="byte-input">
                    <label class="byte-label">Byte ${i}</label>
                    <input type="text" maxlength="2" pattern="[0-9A-Fa-f]{2}" 
                           onchange="updatePacket()" data-byte="${i}"
                           placeholder="00">
                </div>`;
        }
    }
    byteInputsDiv.innerHTML = html;
    
    // íŒ¨í‚· ì´ˆê¸°ê°’ ì„¤ì •
    updatePacket();
}

function updatePacket() {
    const byteInputsDiv = document.getElementById('packetByteInputs');
    const packetInput = document.getElementById('packetInput');
    const headerSelect = document.getElementById('packetHeaderSelect');
    
    const [type, header] = headerSelect.value.split(':');
    let packet = header;  // í—¤ë”ë¡œ ì‹œì‘
    
    // ê° ë°”ì´íŠ¸ ê°’ ìˆ˜ì§‘ (7ë°”ì´íŠ¸)
    for (let i = 1; i < 7; i++) {
        const input = byteInputsDiv.querySelector(`[data-byte="${i}"]`);
        if (input) {
            let value = input.value || '00';
            if (value.length === 1) value = '0' + value;
            packet += value;
        } else {
            packet += '00';
        }
    }
    
    packetInput.value = packet;
}

function createPacketTable(deviceData) {
    const table = document.createElement('table');
    table.className = 'packet-table';
    
    // í—¤ë” í–‰ ìƒì„±
    const headerRow = document.createElement('tr');
    const headers = ['Byte/ì„¤ëª…', 'ëª…ë ¹', 'ìƒíƒœ', 'ìƒíƒœì¡°íšŒ', 'ì‘ë‹µ'];
    headers.forEach(header => {
        const th = document.createElement('th');
        th.textContent = header;
        headerRow.appendChild(th);
    });
    table.appendChild(headerRow);
    
    // ë°”ì´íŠ¸ë³„ í–‰ ìƒì„± (0~7)
    for (let byte = 0; byte < 8; byte++) {
        const row = document.createElement('tr');
        
        // ë°”ì´íŠ¸ ë²ˆí˜¸ì™€ ì„¤ëª…
        const byteCell = document.createElement('td');
        byteCell.className = 'byte-header';
        
        // ë°”ì´íŠ¸ ì„¤ëª… ì°¾ê¸°
        let byteDesc = '';
        if (deviceData.command?.byte_desc?.[byte]) {
            byteDesc = deviceData.command.byte_desc[byte];
        } else if (deviceData.state?.byte_desc?.[byte]) {
            byteDesc = deviceData.state.byte_desc[byte];
        }
        
        byteCell.innerHTML = `Byte ${byte}<br><small>${byteDesc || ''}</small>`;
        row.appendChild(byteCell);
        
        // ê° íŒ¨í‚· íƒ€ì…ë³„ ê°’ ì¶”ê°€
        const types = {
            'command': deviceData.command?.examples?.[0]?.packet,
            'state': deviceData.state?.examples?.[0]?.packet,
            'state_request': deviceData.state_request?.examples?.[0]?.packet,
            'ack': deviceData.ack?.examples?.[0]?.packet
        };
        
        Object.values(types).forEach(packet => {
            const td = document.createElement('td');
            td.className = 'command-cell';
            if (packet) {
                const bytes = packet.match(/.{2}/g) || [];
                td.textContent = bytes[byte] || '--';
            } else {
                td.textContent = '--';
            }
            row.appendChild(td);
        });
        
        table.appendChild(row);
    }
    
    return table;
}

function updatePacketReference(data) {
    const tabContents = document.getElementById('tabContents');
    tabContents.innerHTML = '';
    
    // ê° ë””ë°”ì´ìŠ¤ì— ëŒ€í•œ í…Œì´ë¸” ìƒì„±
    Object.entries(data).forEach(([deviceName, deviceData]) => {
        const deviceSection = document.createElement('div');
        deviceSection.id = `device-${deviceName}`;
        deviceSection.className = 'tab-content';
        
        const table = createPacketTable(deviceData);
        deviceSection.appendChild(table);
        
        tabContents.appendChild(deviceSection);
    });
} 

    </script>
</body>
</html> 